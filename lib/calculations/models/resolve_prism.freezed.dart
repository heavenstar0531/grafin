// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'resolve_prism.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ResolvePrism {
  double get prism1 => throw _privateConstructorUsedError;
  double get base1 => throw _privateConstructorUsedError;
  double get prism2 => throw _privateConstructorUsedError;
  double get base2 => throw _privateConstructorUsedError;
  String get formattedPrism1 => throw _privateConstructorUsedError;
  String get formattedBase1 => throw _privateConstructorUsedError;
  String get formattedPrism2 => throw _privateConstructorUsedError;
  String get formattedBase2 => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ResolvePrismCopyWith<ResolvePrism> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResolvePrismCopyWith<$Res> {
  factory $ResolvePrismCopyWith(
          ResolvePrism value, $Res Function(ResolvePrism) then) =
      _$ResolvePrismCopyWithImpl<$Res, ResolvePrism>;
  @useResult
  $Res call(
      {double prism1,
      double base1,
      double prism2,
      double base2,
      String formattedPrism1,
      String formattedBase1,
      String formattedPrism2,
      String formattedBase2});
}

/// @nodoc
class _$ResolvePrismCopyWithImpl<$Res, $Val extends ResolvePrism>
    implements $ResolvePrismCopyWith<$Res> {
  _$ResolvePrismCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prism1 = null,
    Object? base1 = null,
    Object? prism2 = null,
    Object? base2 = null,
    Object? formattedPrism1 = null,
    Object? formattedBase1 = null,
    Object? formattedPrism2 = null,
    Object? formattedBase2 = null,
  }) {
    return _then(_value.copyWith(
      prism1: null == prism1
          ? _value.prism1
          : prism1 // ignore: cast_nullable_to_non_nullable
              as double,
      base1: null == base1
          ? _value.base1
          : base1 // ignore: cast_nullable_to_non_nullable
              as double,
      prism2: null == prism2
          ? _value.prism2
          : prism2 // ignore: cast_nullable_to_non_nullable
              as double,
      base2: null == base2
          ? _value.base2
          : base2 // ignore: cast_nullable_to_non_nullable
              as double,
      formattedPrism1: null == formattedPrism1
          ? _value.formattedPrism1
          : formattedPrism1 // ignore: cast_nullable_to_non_nullable
              as String,
      formattedBase1: null == formattedBase1
          ? _value.formattedBase1
          : formattedBase1 // ignore: cast_nullable_to_non_nullable
              as String,
      formattedPrism2: null == formattedPrism2
          ? _value.formattedPrism2
          : formattedPrism2 // ignore: cast_nullable_to_non_nullable
              as String,
      formattedBase2: null == formattedBase2
          ? _value.formattedBase2
          : formattedBase2 // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ResolvePrismCopyWith<$Res>
    implements $ResolvePrismCopyWith<$Res> {
  factory _$$_ResolvePrismCopyWith(
          _$_ResolvePrism value, $Res Function(_$_ResolvePrism) then) =
      __$$_ResolvePrismCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double prism1,
      double base1,
      double prism2,
      double base2,
      String formattedPrism1,
      String formattedBase1,
      String formattedPrism2,
      String formattedBase2});
}

/// @nodoc
class __$$_ResolvePrismCopyWithImpl<$Res>
    extends _$ResolvePrismCopyWithImpl<$Res, _$_ResolvePrism>
    implements _$$_ResolvePrismCopyWith<$Res> {
  __$$_ResolvePrismCopyWithImpl(
      _$_ResolvePrism _value, $Res Function(_$_ResolvePrism) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prism1 = null,
    Object? base1 = null,
    Object? prism2 = null,
    Object? base2 = null,
    Object? formattedPrism1 = null,
    Object? formattedBase1 = null,
    Object? formattedPrism2 = null,
    Object? formattedBase2 = null,
  }) {
    return _then(_$_ResolvePrism(
      prism1: null == prism1
          ? _value.prism1
          : prism1 // ignore: cast_nullable_to_non_nullable
              as double,
      base1: null == base1
          ? _value.base1
          : base1 // ignore: cast_nullable_to_non_nullable
              as double,
      prism2: null == prism2
          ? _value.prism2
          : prism2 // ignore: cast_nullable_to_non_nullable
              as double,
      base2: null == base2
          ? _value.base2
          : base2 // ignore: cast_nullable_to_non_nullable
              as double,
      formattedPrism1: null == formattedPrism1
          ? _value.formattedPrism1
          : formattedPrism1 // ignore: cast_nullable_to_non_nullable
              as String,
      formattedBase1: null == formattedBase1
          ? _value.formattedBase1
          : formattedBase1 // ignore: cast_nullable_to_non_nullable
              as String,
      formattedPrism2: null == formattedPrism2
          ? _value.formattedPrism2
          : formattedPrism2 // ignore: cast_nullable_to_non_nullable
              as String,
      formattedBase2: null == formattedBase2
          ? _value.formattedBase2
          : formattedBase2 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ResolvePrism extends _ResolvePrism {
  const _$_ResolvePrism(
      {required this.prism1,
      required this.base1,
      required this.prism2,
      required this.base2,
      required this.formattedPrism1,
      required this.formattedBase1,
      required this.formattedPrism2,
      required this.formattedBase2})
      : super._();

  @override
  final double prism1;
  @override
  final double base1;
  @override
  final double prism2;
  @override
  final double base2;
  @override
  final String formattedPrism1;
  @override
  final String formattedBase1;
  @override
  final String formattedPrism2;
  @override
  final String formattedBase2;

  @override
  String toString() {
    return 'ResolvePrism(prism1: $prism1, base1: $base1, prism2: $prism2, base2: $base2, formattedPrism1: $formattedPrism1, formattedBase1: $formattedBase1, formattedPrism2: $formattedPrism2, formattedBase2: $formattedBase2)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ResolvePrism &&
            (identical(other.prism1, prism1) || other.prism1 == prism1) &&
            (identical(other.base1, base1) || other.base1 == base1) &&
            (identical(other.prism2, prism2) || other.prism2 == prism2) &&
            (identical(other.base2, base2) || other.base2 == base2) &&
            (identical(other.formattedPrism1, formattedPrism1) ||
                other.formattedPrism1 == formattedPrism1) &&
            (identical(other.formattedBase1, formattedBase1) ||
                other.formattedBase1 == formattedBase1) &&
            (identical(other.formattedPrism2, formattedPrism2) ||
                other.formattedPrism2 == formattedPrism2) &&
            (identical(other.formattedBase2, formattedBase2) ||
                other.formattedBase2 == formattedBase2));
  }

  @override
  int get hashCode => Object.hash(runtimeType, prism1, base1, prism2, base2,
      formattedPrism1, formattedBase1, formattedPrism2, formattedBase2);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ResolvePrismCopyWith<_$_ResolvePrism> get copyWith =>
      __$$_ResolvePrismCopyWithImpl<_$_ResolvePrism>(this, _$identity);
}

abstract class _ResolvePrism extends ResolvePrism {
  const factory _ResolvePrism(
      {required final double prism1,
      required final double base1,
      required final double prism2,
      required final double base2,
      required final String formattedPrism1,
      required final String formattedBase1,
      required final String formattedPrism2,
      required final String formattedBase2}) = _$_ResolvePrism;
  const _ResolvePrism._() : super._();

  @override
  double get prism1;
  @override
  double get base1;
  @override
  double get prism2;
  @override
  double get base2;
  @override
  String get formattedPrism1;
  @override
  String get formattedBase1;
  @override
  String get formattedPrism2;
  @override
  String get formattedBase2;
  @override
  @JsonKey(ignore: true)
  _$$_ResolvePrismCopyWith<_$_ResolvePrism> get copyWith =>
      throw _privateConstructorUsedError;
}
